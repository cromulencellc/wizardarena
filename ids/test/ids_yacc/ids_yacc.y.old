// Copyright 2011 Bobby Powers. All rights reserved.
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

// based off of Appendix A from http://dinosaur.compilertools.net/yacc/

%{

package main

import (
    "bufio"
    "fmt"
    "os"
)

/*
const (
    RULE_ALERT = iota
    RULE_ADMIT = iota
    RULE_BLOCK = iota
)
*/

%}

// fields inside this union end up as the fields in a structure known
// as ${PREFIX}SymType, of which a reference is passed to the lexer.
%union{
    rule_type int
    rule_item int 
    fill_item int
    rule_string string
    cur_string string
}

// any non-terminal which returns a value needs a type, which is
// really a field name in the above union struct
%type <rule_type> expr

// same for terminals
// %token <rule_string> STRING

%token <cur_string> STRING

%token RULE_ALERT
%token RULE_ADMIT
%token RULE_BLOCK

%token ATTRIBUTE_NAME
%token ATTRIBUTE_SIDE
%token ATTRIBUTE_REGEX
%token ATTRIBUTE_FLUSH

//%token OPEN_COLON
//%token CLOSE_COLON

%type <rule_item> RULE_ALERT, RULE_ADMIT, RULE_BLOCK
//%type <fill_item> OPEN_COLON, CLOSE_COLON

%%


list    : /* empty */
            | list stat '\n'
    ;

stat    :    expr
                {
            fmt.Printf( "Result: %d\n", $1 );
        }
    ;

expr    :   RULE_ALERT '(' STRING ')'
                { 
                    fmt.Printf( "ALERT (%d): %s\n", $1, $3 );
                    $$ = $1; 
                }
        |   RULE_ADMIT '(' STRING ')'
                {
                    fmt.Printf( "ADMIT (%d): %s\n", $1, $3 );
                    $$ = $1;
                }
        |   RULE_BLOCK '(' STRING ')'
                {
                    fmt.Printf( "BLOCK: %s\n", $3 );
                    $$ = $1;
                }
    ;


%%      /*  start  of  programs  */

func (l *IDSLex) Error(s string) {
    fmt.Printf("syntax error: %s\n", s)
}

func main() {
    fi := bufio.NewReader(os.NewFile(0, "stdin"))

    for {
        var eqn string
        var ok bool

        fmt.Printf("equation: ")
        if eqn, ok = readline(fi); ok {
            IDSParse(&IDSLex{S: eqn})
        } else {
            break
        }
    }
}

func readline(fi *bufio.Reader) (string, bool) {
    s, err := fi.ReadString('\n')
    if err != nil {
        return "", false
    }
    return s, true
}
